<style>
    .insect-sprite {
        width: 20px;
        height: 20px;
    }

    #insect-id {
        left: 50vw;
        top: 50vh;
    }
</style>

<title>My Hugo Page</title>
<h1>Welcome to My <span style="font-family: chiller;">FLY</span> Page</h1>
<p style="font-family: chiller;">there is no escape from the FLY...</p>

<div id="insect-id">
    <img src="fly.png" class="insect-sprite" alt="insect">
</div>


<script>
    const insect = document.getElementById('insect-id');
    insect.style.position = 'absolute';

    const kFlySpeed = 5;
    const kStopTimeMin = 1000;
    const kStopTimeMax = 4000;
    const kWakeUpThreshold = 60;
    const kFlyAwayMaxSpeed = 50;
    const kFlyAwayThreshold = kWakeUpThreshold;
    const kWallThreshold = 50;
    const kWallSpeed = 10;

    let state = "NULL";
    let cursor_x = 0;
    let cursor_y = 0;
    let accel_x = 0;
    let accel_y = 0;
    let velo_x = 0;
    let velo_y = 0;

    let timeout_id;

    // Listen for mousemove events
    document.addEventListener('mousemove', (event) => {
        cursor_x = event.clientX; // X-coordinate of the cursor
        cursor_y = event.clientY; // Y-coordinate of the cursor
    });

    function InsectUpdate() {
        if (state == "moving") {
            // Get curr pos.
            const curr_x = parseFloat(insect.style.left) || window.innerWidth / 2;
            const curr_y = parseFloat(insect.style.top) || window.innerHeight / 2;

            // Get vector from cursor to insect.
            const dist_x = curr_x - cursor_x;
            const dist_y = curr_y - cursor_y;
            const dist_mag = Math.sqrt(dist_x * dist_x + dist_y * dist_y);
            // Turn vector into away trajectory.
            // let away_x = 0;
            // let away_y = 0;
            // if (dist_mag < kFlyAwayThreshold) {
            //     const x = dist_mag / kFlyAwayThreshold;
            //     const speed = (2 * x * x * x - 3 * x * x + 1) * kFlyAwayMaxSpeed;
            //     away_x = dist_x * speed / dist_mag
            //     away_y = dist_y * speed / dist_mag
            // }

            // Bounce off walls.
            if (curr_x < 0 && velo_x < 0) {
                velo_x *= -1;
            }
            if (curr_x > window.innerWidth && velo_x > 0) {
                velo_x *= -1;
            }
            if (curr_y < 0 && velo_y < 0) {
                velo_y *= -1;
            }
            if (curr_y > window.innerHeight && velo_y > 0) {
                velo_y *= -1;
            }

            // Update accel and velo and pos.
            accel_x = (2 * Math.random() - 1) * 8;
            accel_y = (2 * Math.random() - 1) * 8;
            velo_x = velo_x + accel_x;
            velo_y = velo_y + accel_y;
            const x = curr_x + velo_x;
            const y = curr_y + velo_y;
            insect.style.left = `${x}px`;
            insect.style.top = `${y}px`;

            // Apply drag.
            const velo_mag = Math.sqrt(velo_x * velo_x + velo_y * velo_y);
            const drag_x = 0.001 * velo_mag * velo_mag * -velo_x / velo_mag;
            const drag_y = 0.001 * velo_mag * velo_mag * -velo_y / velo_mag;
            velo_x += drag_x;
            velo_y += drag_y;

            // Rotate sprite.
            const angle = Math.atan2(velo_y, velo_x) * 180 / Math.PI + 90;
            insect.style.transform = `rotate(${angle}deg)`;

            // Check mouse position if reset timeout.
            if (dist_mag < kWakeUpThreshold) {
                clearTimeout(timeout_id);
                const time_to_stop = Math.random() * (kStopTimeMax - kStopTimeMin) + kStopTimeMin
                timeout_id = setTimeout(() => {
                    StopMoving();
                }, time_to_stop);
            }

        }
        if (state == "stopped") {
            const curr_x = parseFloat(insect.style.left) || window.innerWidth / 2;
            const curr_y = parseFloat(insect.style.top) || window.innerHeight / 2;
            const dist_x = curr_x - cursor_x;
            const dist_y = curr_y - cursor_y;
            if (Math.sqrt(dist_x * dist_x + dist_y * dist_y) < kWakeUpThreshold) {
                StartMoving();
            }
            accel_x = 0;
            accel_y = 0;
            velo_x = 0;
            velo_y = 0;
        }
    }

    function StartMoving() {
        state = "moving";
        const time_to_stop = Math.random() * (kStopTimeMax - kStopTimeMin) + kStopTimeMin
        timeout_id = setTimeout(() => {
            StopMoving();
        }, time_to_stop);

        console.log("start moving");
    }

    function StopMoving() {
        console.log("stop moving");
        state = "stopped";
    }

    function Main() {
        InsectUpdate();
        setTimeout(() => {
            Main();
        }, 50);
    }

    // Initial call.
    StartMoving();
    Main();

</script>