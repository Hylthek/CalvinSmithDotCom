{"/abstract/":{"data":{"":" ","intro#Intro":" Minimally invasive in-situ bioprinting is a form of automated robotic surgery that allows for advanced organ repair. Traditionally, the organ is printed in-vitro and transplanted; however, there are drawbacks to this, one being that repair sites may drastically change in the time it takes between printing and transplanting. Existing solutions for robotic surgery include use of the Da Vinci Surgical System with its manual control. Unfortunately, procedures like bioprinting require many precise, repetitive movements, something difficult for a surgeon to perform manually. Additionally, automation would allow a surgeon to focus on the procedure as a whole, instead of on each task individually, increasing safety.\nA key aspect of automated robotic surgery is the use of movement commands (toolpaths) that are sent to the robot. Therefore, there is a need for intuitive, real-time development of complex toolpathing for the surgical field, as surgery is unpredictable and time-sensitive. Current solutions involve generating toolpaths in existing computer-aided manufacturing (CAM) software. This process is slow, and generated toolpaths are unalterable.\nA computer application is proposed which will allow a surgeon to generate toolpaths in a timely manner, making automated robotic surgery safer. To achieve this, the program must be intuitive, and must run quickly. Additionally, a requirement specific to bioprinting must be met. In bioprinting, the toolpaths output by the application must maintain constant separation; if toolpaths are too far apart, they will not adhere to each other, and if they are too close together, they will overlap and create areas of unwanted material.","methods#Methods":"Before generating toolpaths, geometry needs to be created to contain those paths. Basis-surfaces (b-surfaces) were used because of their smoothness and interactive simplicity. B-surfaces are mathematically defined surfaces that maintain continuous curvature at every point. Any toolpath generated across a b-surface will, in turn, be smooth, reducing future algorithmic complexity. Moreover, a b-surface is defined by only a small grid of control points. This allows manipulation of the surface to be clutter-free and intuitive (Fig. 1). Manipulation of the surface was implemented through a virtual reality (VR) user interface (UI) because it is an intuitive way to visualize and modify 3D geometry.\nFigure 1: The basis-surface and its 6x6 grid of control points. To maintain workflow simplicity, automatic surface generation is implemented. If a surgeon needs to cover an organic defect quickly, it is desirable to only have to trace a loop around the defect and run an algorithm. Using least-squares optimization, paired with the mathematical nature of b-surfaces, we can instantaneously fit a surface to any closed loop. Additionally, surfaces can be changed and then refit to the loop while retaining their alterations (Fig. 2).\nFigure 2: Demonstration of loop-fitting and loop-refitting. To achieve constant toolpath separation, path generation will be done procedurally, point-by-point, rather than purely mathematically. This achieves our required constant separation, but sacrifices computational speed. To account for this, algorithmic optimizations such as caching and input filtering are used to reduce generation time.","results-conclusions-and-discussions#Results, Conclusions, and Discussions":"The created software demonstrates effortless workflow. Given a virtual tissue defect, a surgeon will only perform a few simple tasks in order to design a toolpath (Fig. 3). This is in contrast to most CAM software, where complex functionality is required to maximize precision, at the cost of simplicity and speed. Moreover, every algorithm except toolpath generation is executed in real-time. A benefit of this is that in the event of a design alteration, a task can be redone without additional delay.\nFigure 3: Typical workflow performed by user. For toolpath generation, runtimes were recorded for two toolpath modes as well as two surface sizes. Four tests were conducted: the generation time for small concentric paths, small rectilinear paths, large concentric paths, and large rectilinear paths. Respective times were 18.5s, 13.5s, 151s, \u0026 106s (Fig. 4). These results show that toolpath generation is not only the slowest part of design, but that computation times grow rapidly as the surface size increases. Although this is not ideal, the process can be greatly optimized. The algorithm currently iterates over all vertices of the toolpath, but the surface could instead be split into chunks, meaning that only a fraction of the toolpath is run. Additionally, compute shaders, programs executed on the GPU instead of the CPU, could run multiple algorithms at the same time.\nFigure 4: Four toolpathed surfaces and their generation times in the Unity runtime profiler. Separation measurements were sampled for concentric and rectilinear toolpaths. Two types of rectilinear toolpaths were sampled: “self-straightening” and “non-straightening”. The target separation was 0.004 units of length. Measurements were plotted on a binned histogram and a kernel density estimation plot (Fig. 5). Although concentric toolpaths outperform the others in stepover precision, they do not provide as much structural integrity compared to rectilinear toolpaths, with their much stronger, straight lines. This is in contrast to self-straightened toolpaths, which instead sacrifice precision for maximum structural integrity. Finally, non-straightened toolpaths demonstrate a compromise between concentric and straightened rectilinear toolpaths, boasting acceptable stepover precision, as well as suitably robust structure. All three toolpath modes can be used in combination to facilitate design and maximize safety.\nFigure 5: Stepover samples plotted in binned-histograms and KDE curves. Notice the difference in the ploted domain between RectStraight and the others. "},"title":"Summer 2025 Undergraduate Research Abstract"},"/extras/":{"data":{"":"\rThis is the debug information output by FindStepoverPoints() (AKA, FSP), a function which I spent a very long time battling with.\nThis is all the debug information rendered during a full toolpath generation. Every small step forward uses FSP. Clearly, FSP needs to run quickly. Does it? no.\nThis is some more FSP debug information. It shows the valid band of vertices that should be distance-checked. Without this optimization, {insert_name_of_my_software} has no hope of breaking medical frontiers.\nHere is an attempt at rectilinear toolpathing. Unfortunately, the procedural nature of the algorithm increases instability and creates these banana shapes.\nIf I move from 3D space into UV space, it becomes a lot easier to simple squeeze each toolpath into a line. This would create a stabilizing affect. A algorithmic homeostatis, if you will. Anyway, thats what I did.\nHeres what it looks like in 3D space. A drawback of doing it this way is that “straight” can be non-straight given a warped surface. I try not to think about that.\nHeres a before…\n…and an after.\nAnd here’s a cool combination of concentric and rectilinear toolpaths. Reminded me of the Black Mesa logo.\nAnother cool shape.\nHeres what my plots looked like before I realized I’m not a business major (Excel -\u003e MATLAB). This one in particular took me a couple of hours to format.\nHeres a previous version of my flowchart. Yea…"},"title":"Extras"},"/situcamdocumentation/":{"data":{"":" BezierSurfaceRenderer.cs - Unused.\nBsplineManager.cs - Stores control point locations and contains functions to calculate basis-surface points.\nBSurfaceGcodeGenerator.cs - Defines functions that allow for procedural toolpathing along a basis-surface.\nBsurfaceGridLineManager.cs - Unused.\nBSurfaceMeshHandler.cs - Creates the mesh of the basis surface.\nCallFitSurfaceToDrawing.cs - Turns a ray interaction into one of two function call.\nCallGcodeGenerate.cs - Unused.\nCallGcodePerform.cs - Unused.\nCallLiveControlToggle.cs - Turns a ray interaction into a function call.\nCallToggleDrawingMode.cs - Turns a ray interaction into a function call.\nCallToggleToolpathingMode.cs - Turns a ray interaction into a function call.\nConformalToolpathingManager.cs - Handles main logic for toolpathing UI.\nConformalToolpathingModeManager.cs - Contains public function to toggle toolpathing UI active state.\nConnectToolpathNodes.cs - Unused.\nControlPolygonLineManager.cs - Renders control polygon for basis-surface.\nControlPolygonLiquifyToolManager.cs - Handles logic for basis-surface liquify tool.\nDeleteAtPoint.cs - Handles logic for deleting toolpath vertices.\nDisableOnStart.cs - Self explanatory.\nDisappearOnStart.cs - Unused.\nDrawingHandler.cs - Main logic for loop-drawing UI.\nDrawingModeHandler.cs - Contains public function to toggle loop-drawing UI active state.\nEnableOnButtonTimed.cs - Handles enabling of scripts for a duration after a button press.\nFollow.cs - Unused.\nFollowClosestToolpath.cs - Makes a GameObject move to a vertex on the toolpath that is the closest point to a target.\nGcodeGenerator.cs - Unused.\nGcodePerformer.cs - Unused.\nGenerateConcentricToolpath.cs - Turns a ray interaction into a variable increment.\nGenerateRectilinearToolpath.cs - Turns a ray interaction into a variable increment.\nLiveControlGcodeSender.cs - Reads transform of virtual end-effector and makes calls to UnityTcpClient.\nLiveControlManipulationHandler.cs - Handles movement of virtual end-effector via controller input.\nMoveHandheldMenu.cs - Unused.\nMoveJaws.cs - Handles movement of end-effector jaw visuals.\nPointer.cs - Contains one reference to a GameObject.\nPressedButtonMovement.cs - Moves a button when that button is pressed.\nRayGrabbing.cs - Allows a GameObject to be grabbed and moved by a controller.\nRenderBezierCurve.cs - Unused.\nSurfaceFittingManager.cs - Contains algorithms for fitting a basis-surface to a loop heuristically and with least-squares optimization.\nUnityTcpClient.cs - Establishes a TCP connection through an IP address and contains a function to send strings over the connection."},"title":"SituCamDocumentation"}}